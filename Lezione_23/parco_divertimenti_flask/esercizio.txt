Esercizio: Sistema di Gestione di un Parco Divertimenti (OOP + Flask)
Completion requirements

In questo esercizio,
dovrai scrivere il codice per un sistema che gestisce le attrazioni di
un parco divertimenti e che espone alcune informazioni tramite un’applicazione Flask.
L’obiettivo è applicare i principi di ereditarietà e classi astratte,
e sperimentare le richieste HTTP GET di Flask.

Specifiche del Problema

Classe Ride

La classe Ride rappresenta un’attrazione generica del parco.
È una classe astratta e non può essere istanziata direttamente.
Ogni attrazione ha:

    un identificativo (id) di tipo stringa;
    un nome (name) di tipo stringa;
    un’altezza minima richiesta (min_height_cm) di tipo intero.

Metodi:

    category():
        metodo astratto.
        Deve essere implementato nelle sottoclassi per
        restituire la categoria dell’attrazione (es. "roller_coaster", "family").

    base_wait():
        metodo astratto.
        Deve essere implementato nelle sottoclassi e deve restituire l’attesa base in minuti.

    info():
        metodo concreto che restituisce un dizionario con le informazioni principali
        dell’attrazione (id, nome, altezza minima, categoria e attributi specifici).

    wait_time(crowd_factor: float = 1.0):
        metodo concreto
        che restituisce l’attesa stimata in minuti.
        L’attesa è calcolata come base_wait() * crowd_factor, arrotondata all’intero positivo.

Classe RollerCoaster

La classe RollerCoaster rappresenta una montagna russa e eredita da Ride.

Attributi aggiuntivi:

    inversions: numero di inversioni presenti nel tracciato (ad esempio 3 o 5).

Metodi:

    category():
        restituisce la stringa "roller_coaster".

    base_wait():
        restituisce l’attesa base in minuti (ad esempio 40).

    info():
        estende il metodo della superclasse includendo anche il numero di inversioni.

Classe Carousel

La classe Carousel rappresenta una giostra con animali e eredita da Ride.

Attributi aggiuntivi:

    animals:
        lista di animali presenti sulla giostra (ad esempio ["horse", "swan", "tiger"]).

Metodi:

    category():
        restituisce la stringa "family".

    base_wait():
        restituisce l’attesa base in minuti (ad esempio 10).

    info():
        estende il metodo della superclasse includendo la lista di animali.

Classe Park

La classe Park rappresenta il contenitore principale del sistema, che gestisce tutte le attrazioni presenti nel parco.

Attributi:

    rides: dizionario che associa a ogni identificativo (id) l’oggetto Ride corrispondente.

Metodi:

    add(ride):
        aggiunge un’attrazione al parco.

    get(ride_id):
        restituisce l’attrazione corrispondente all’ID specificato oppure None se non esiste.

    list_all():
        restituisce una lista di tutte le attrazioni (puoi ordinare per categoria e nome, opzionale).

Nel codice principale dovrà essere creato un parco e dovranno essere create almeno due attrazioni,
una di tipo RollerCoaster e una di tipo Carousel.

Applicazione Flask

Crea un’applicazione Flask che esponga alcune route GET per consultare i dati del parco.
Le funzioni delle route devono restituire oggetti json. 

Route richieste

GET /

Restituisce un json con:

    una breve descrizione del servizio (es. "Welcome to Park API"),
    alcuni link testuali che indicano le altre route disponibili (es. "/rides", "/rides/rc1", "/rides/rc1/wait/4.0").
    Devi generare i link dinamicamente con url_for() e poi inserirli nel json.

GET /rides

Restituisce un json di attrazioni presenti nel parco.
Ogni elemento del json può essere:

    una stringa descrittiva (es. "rc1 - Vortex (roller_coaster) - min 140cm"), oppure
    un dizionario con i campi principali dell’attrazione.

La scelta è libera, ma deve essere coerente in tutto il programma.

GET /rides/<ride_id>

Restituisce un json con un solo elemento che rappresenta i dettagli dell’attrazione con l’ID specificato.

GET /rides/<ride_id>/wait/crowd

Restituisce un json con le informazioni sull’attesa stimata per l’attrazione specificata.

    Il parametro crowd è facoltativo e indica un fattore di affollamento (di default 1.0).
    L’output può essere, ad esempio, una json contenente una stringa "Attesa: 60 minuti" oppure un dizionario {"wait_min": 60}.

Cosa strutturare l'esercizio

    Un file main.py contenente:
        le classi Ride, RollerCoaster, Carousel, Park;
        un parco popolato con almeno due giostre (una per tipo);
        l’applicazione Flask con tutte le route richieste;
    Il formato delle risposte deve essere coerente: tutte le route devono restituire oggetti json.

Esecuzione dell’applicazione

Il programma può essere eseguito in due modi:

    da riga di comando:

flask --app main run --debug

    oppure direttamente nel file Python:

app.run(debug=True, host="127.0.0.1", port=5000)