Esercizio: Gestione di un Rifugio per Animali (GET + POST)
Completion requirements

In questo esercizio dovrai scrivere il codice per un sistema che gestisce gli animali di un rifugio e che espone
alcune informazioni e funzionalità tramite un’applicazione Flask.
L’obiettivo è applicare i principi di ereditarietà e classi astratte, e sperimentare sia le richieste HTTP GET
sia le richieste HTTP POST.

Specifiche del Problema:

Classe Animal

La classe Animal rappresenta un animale generico del rifugio.
È una classe astratta e non può essere istanziata direttamente.

Ogni animale ha:

    un identificativo id di tipo stringa (es. "d1", "c3"),

    un nome name di tipo stringa,

    un’età age_years di tipo intero (anni),

    un peso weight_kg di tipo float (chilogrammi).

Metodi

    species(): metodo astratto.
    Deve essere implementato nelle sottoclassi per restituire la specie dell’animale, ad esempio "dog" o "cat".

    daily_food_grams(): metodo astratto.
    Deve essere implementato nelle sottoclassi e deve restituire la quantità di cibo giornaliera raccomandata in grammi.

    info(): metodo concreto.
    Restituisce un dizionario con le informazioni principali dell’animale, ad esempio:
    { "id": ..., "name": ..., "species": ..., "age_years": ..., "weight_kg": ..., # più eventuali campi specifici delle sottoclassi }

    bmi_like(): metodo concreto che restituisce un valore derivato (simile a un indice di “forma fisica”), ad esempio calcolato come:
    weight_kg / (age_years + 1)

    Il dettaglio della formula è lasciato libero, l’importante è che sia coerente e restituisca un numero (float).

Classe Dog

La classe Dog rappresenta un cane e eredita da Animal.
Attributi aggiuntivi

    breed: razza del cane, stringa (es. "labrador"),

    is_trained: booleano che indica se il cane è addestrato (True/False).

Metodi

    species(): restituisce la stringa "dog".

    daily_food_grams(): restituisce la quantità di cibo giornaliero in grammi.
    Puoi usare una formula plausibile, ad esempio:
    return 200 + age_years * 50

    oppure un’altra a tua scelta, purché sia chiaro che il risultato rappresenta grammi di cibo al giorno.

    info(): estende il metodo della superclasse includendo anche breed e is_trained.

Classe Cat

La classe Cat rappresenta un gatto e eredita da Animal.
Attributi aggiuntivi

    indoor_only: booleano che indica se il gatto vive solo in casa (True/False),

    favorite_toy: stringa che rappresenta il gioco preferito (es. "ball", "mouse").

Metodi

    species(): restituisce la stringa "cat".

    daily_food_grams(): restituisce la quantità di cibo giornaliero in grammi.
    Anche qui puoi usare una formula plausibile, ad esempio:
    return 100 + age_years * 30

    info(): estende il metodo della superclasse includendo anche indoor_only e favorite_toy.

Classe Shelter

La classe Shelter rappresenta il contenitore principale del sistema, che gestisce tutti gli animali presenti nel rifugio.
Attributi

    animals: dizionario che associa a ogni identificativo (id) l’oggetto Animal corrispondente, ad esempio:
    { "d1": <Dog ...>, "c1": <Cat ...>, ... }

    adoptions (opzionale ma consigliato): struttura dati per gestire lo stato di adozione, ad esempio un dizionario:
    { "d1": "Mario Rossi", "c1": "Luca Bianchi" }

    dove la chiave è l’id dell’animale e il valore è il nome dell’adottante.

Metodi

    add(animal): aggiunge un animale al rifugio.
    Se esiste già un animale con lo stesso id, puoi decidere se sovrascriverlo o ignorare l’operazione (nel contesto dell’esercizio è sufficiente una scelta semplice e documentata nei commenti).

    get(animal_id): restituisce l’oggetto Animal corrispondente all’ID specificato oppure None se non esiste.

    list_all(): restituisce una lista di tutte le istanze di Animal presenti nel rifugio (puoi decidere se restituire direttamente gli oggetti o piuttosto una lista di dizionari generati con info()).

    is_adopted(animal_id): restituisce True/False a seconda che l’animale risulti adottato nella struttura adoptions.

    set_adopted(animal_id, adopter_name): registra l’adozione per un dato animale, salvando il nome dell’adottante.

Nel codice principale dovrà essere creato un rifugio e dovranno essere creati almeno due animali, uno di tipo Dog e uno di tipo Cat, che saranno aggiunti al rifugio prima di avviare l’app Flask.
Applicazione Flask

Crea un’applicazione Flask che esponga alcune route GET per consultare i dati del rifugio e alcune route POST per modificare lo stato (ad esempio aggiungere animali e registrare adozioni).
Le funzioni delle route devono restituire oggetti JSON (non stringhe semplici).
Route GET richieste
1. GET /

Restituisce un JSON con:

    una breve descrizione del servizio, ad esempio:
     
    { "message": "Welcome to Animal Shelter API" }

    alcuni link testuali che indicano le altre route disponibili, ad esempio:

        /animals

        /animals/d1

        /animals/d1/food

        /animals/d1/adoption

    Questi link devono essere generati dinamicamente con url_for() e poi inseriti nel JSON, ad esempio:
    { "message": "...", "links": { "list_animals": url_for("list_animals"), "sample_dog": url_for("get_animal", animal_id="d1"), ... } }

2. GET /animals

Restituisce un JSON con la lista degli animali presenti nel rifugio.

Ogni elemento della lista può essere:

    una stringa descrittiva, ad esempio
    "d1 - Rex (dog) - 2 years - 18.5kg",

    oppure

    un dizionario con i campi principali dell’animale (quelli restituiti da info()).

La scelta è libera, ma deve essere coerente in tutto il programma (se scegli la rappresentazione come dizionario, usala ovunque per le liste).
3. GET /animals/<animal_id>

Restituisce un JSON con un solo elemento che rappresenta i dettagli dell’animale con l’ID specificato.

Ad esempio:
{ "id": "d1", "name": "Rex", "species": "dog", "age_years": 2, "weight_kg": 18.5, "breed": "border collie", "is_trained": true }

Se l’animale non esiste, la route dovrebbe restituire un JSON di errore (es. {"error": "Animal not found"}) con status code appropriato (ad esempio 404).
4. GET /animals/<animal_id>/food

Restituisce un JSON con le informazioni sul cibo giornaliero stimato per l’animale specificato.

L’output può essere, ad esempio:
{ "id": "d1", "daily_food_grams": 350 }

oppure una struttura più ricca a tua scelta, purché sia JSON.

Anche qui, se l’animale non esiste, va gestito l’errore.
5. GET /animals/<animal_id>/adoption

Restituisce lo stato di adozione dell’animale specificato.

Esempi di output:

Animale non adottato:
{ "id": "d1", "adopted": false }

Animale adottato:
{ "id": "d1", "adopted": true, "adopter_name": "Mario Rossi" }
Route POST richieste

Le seguenti route servono per modificare lo stato del rifugio (aggiungere animali, registrare adozioni).
In tutte le route POST il body della richiesta deve essere in formato JSON e deve essere letto tramite request.get_json().
1. POST /animals/add

Permette di aggiungere un nuovo animale al rifugio.

Il body JSON deve contenere le informazioni necessarie per creare l’animale e un campo che specifica il tipo, ad esempio "dog" o "cat".

Esempio per un cane:
{ "type": "dog", "id": "d3", "name": "Rex", "age_years": 2, "weight_kg": 18.5, "breed": "border collie", "is_trained": true }

Esempio per un gatto:
{ "type": "cat", "id": "c5", "name": "Micia", "age_years": 3, "weight_kg": 4.2, "indoor_only": true, "favorite_toy": "ball" }

La funzione della route deve:

    leggere il JSON dalla richiesta;

    verificare che il campo "type" sia presente e valido ("dog" o "cat");

    controllare che i campi richiesti (id, name, ecc.) siano presenti;

    creare l’istanza della sottoclasse corretta (Dog o Cat);

    aggiungere l’animale al Shelter con shelter.add(...);

    restituire un JSON di conferma, ad esempio:
    { "status": "ok", "added": { "id": "d3", "species": "dog" } }

In caso di errore (id già esistente, campi mancanti, tipo non riconosciuto) deve restituire un JSON di errore con uno status code adeguato (es. 400 Bad Request).
2. POST /animals/<animal_id>/adopt

Registra l’adozione di un animale.

Il body JSON deve contenere almeno il nome dell’adottante, ad esempio:
{ "adopter_name": "Mario Rossi" }

La funzione della route deve:

    verificare che l’animale con id animal_id esista nel rifugio;

    leggere il nome dell’adottante dal JSON;

    aggiornare la struttura di adozioni del Shelter (ad esempio con shelter.set_adopted(animal_id, adopter_name));

    restituire un JSON di conferma, ad esempio:
    { "id": "d1", "adopted": true, "adopter_name": "Mario Rossi" }

Se l’animale non esiste, oppure è già adottato (se vuoi gestire anche questo caso), la route deve restituire un JSON di errore e uno status code appropriato (es. 404 o 400).
Come strutturare l’esercizio

Crea un file main.py contenente:

    le classi Animal, Dog, Cat, Shelter;

    un’istanza di Shelter popolata con almeno un cane e un gatto di esempio;

    l’applicazione Flask con tutte le route GET e POST richieste;

    il codice per avviare l’app (solo se vuoi usare app.run() dal file Python).

Il formato delle risposte deve essere coerente: tutte le route devono restituire oggetti JSON.
Test dell’applicazione con la libreria requests

Oltre all’implementazione dell’applicazione Flask, è richiesto di scrivere un semplice script di test che esegua alcune richieste HTTP verso il server e stampi le risposte ricevute.

Crea un file, ad esempio test_api.py, che utilizza la libreria requests per chiamare le route dell’applicazione Flask.

Assunzioni:

    si assume che l’app Flask del rifugio sia in esecuzione su
    http://127.0.0.1:5000

    lo script di test va eseguito in un secondo terminale, dopo aver avviato il server (ad esempio con python main.py o flask --app main run).

Nel file di test dovrai:

    impostare gli header base per lavorare con JSON, ad esempio:

    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
    }

    usare le funzioni di requests (get, post, …) per chiamare le varie route,

    stampare a schermo, il contenuto JSON di ogni risposta (puoi usare response.json() e print).

Lo script di test dovrà effettuare almeno le seguenti operazioni:

    GET /

        Verificare che l’API risponda correttamente e stampare il messaggio di benvenuto e i link.

    GET /animals

        Stampare la lista iniziale degli animali (dovrebbero esserci almeno il cane e il gatto creati nel codice principale).

    GET /animals/d1 (o l’ID che hai scelto per il cane di esempio)

        Stampare i dettagli dell’animale.

    GET /animals/d1/food

        Stampare il cibo giornaliero stimato per l’animale.

    GET /animals/d1/adoption

        Verificare e stampare lo stato di adozione iniziale (atteso adopted: false).

    POST /animals/add – aggiunta di un nuovo cane

        Inviare un JSON con i dati di un nuovo cane (nuovo id, name, age_years, …)

        Stampare la risposta e poi usare un GET /animals/<nuovo_id> per verificare che sia stato aggiunto.

    POST /animals/add – aggiunta di un nuovo gatto

        Inviare un JSON con i dati di un nuovo gatto (type: "cat", ecc.)

        Stampare la risposta e controllare con un GET che sia presente.

    POST /animals/<animal_id>/adopt – registrare un’adozione

        Scegliere uno degli animali (es. il nuovo cane) e inviare un JSON con "adopter_name".

        Stampare la risposta.

        Subito dopo, fare un GET /animals/<animal_id>/adoption e verificare che ora risulti adopted: true con il nome giusto.

Esecuzione dell’applicazione

Il programma può essere eseguito in due modi:

    da riga di comando:
    flask --app main run --debug

    oppure direttamente nel file Python, con:
    app.run(debug=True, host="127.0.0.1", port=5000)

